# 指针
在 C 语言中，可以用 int 存储整型的数据： int num = 97 ， 也可以用 char 存储字符型的数据： char ch = 'a'。

任何数据载入内存后，在内存都有它们的地址，这就是指针。而为了保存这一数据在内存中的地址，我们就需要指针变量。

因此：**指针是数据在内存中的地址，而指针变量是用来保存地址的变量。**

# 指针变量
## 定义指针变量
定义指针变量时，在变量名前写一个 * 星号，这个变量就变成了指针变量。必要时要加( ) 来避免优先级的问题。

```c
int i = 10; // int 类型变量
int* p_int; // 指向 int 类型变量的地址

char c = 'a'; // char 类型变量
char* p_char; // 指向 char 类型变量的地址

double d = 2.1; // double 类型变量
double* p_double; // 指向 double 类型变量的地址
```

## 指针变量的属性
普通变量有 2 个特性：变量的类型、变量的值。而指针变量也符合普通变量的特性： 指针变量的类型、指针变量的值。

- 指针变量的类型：指针变量的类型决定了这个指针所指向的内存所占用的字节数，以及如何解释这些字节信息。指针变量的类型要和它指向的数据的类型匹配。
- 指针的值：比如一个 int 类型的 i 变量 ，其地址的值是 0037F9E4 ，那么 p_int 的值就是 0037F9E4。

*p_int  :  将从地址 0037F9E4 开始解析，因为 p_int 是 int 类型指针，而 int 占 4 个字节，因此向后连续取 4 个字节（0037F9E4、0037F9E5、0037F9E6、0037F9E7），并将这 4 个字节的二进制数据解析为一个整数。

*p_char :  将从地址 0037F9CF 开始解析，因为 p_char 是 char 类型指针，而 char 占 1 个字节，因此向后连续取 1 个字节，并将这 1 个字节的二进制数据解析为一个字符。

## 取地址
使用 & 运算符取得一个变量的地址。

```c
#include <stdio.h>

int main() {
	int i = 10;
	printf_s("%10s = %p\n", "&i", &i); // &i，取 int 类型变量 i 的地址
	int* p_int = &i; // 指针变量 p_int 指向 int 类型变量 i 的地址
	//p_int = &i;
	printf_s("%10s = %p\n", "p_int", p_int);
	printf_s("%10s = %p\n", "&p_int", &p_int); // p_int 也是一个变量，即指针变量；&p_int，取指针变量 p_int 的地址

	char c = 'a';
	printf_s("%10s = %p\n", "&c", &c); // &c，取 char 类型变量 c 的地址
	char* p_char = &c;  // 指针变量 p_char 指向 char 类型变量 c 的地址
	//p_char = &c;
	printf_s("%10s = %p\n", "p_char", p_char);
	printf_s("%10s = %p\n", "&p_char", &p_char); // p_char 也是一个变量，即指针变量；&p_char，取指针变量 p_char 的地址

	double d = 2.1;
	printf_s("%10s = %p\n", "&d", &d); // &d，取 double 类型变量 d 的地址
	double* p_double = &d;  // 指针变量 p_double 指向 double 类型变量 d 的地址
	//p_double = &d;
	printf_s("%10s = %p\n", "&p_double", p_double);
	printf_s("%10s = %p\n", "&p_double", &p_double); // p_double 也是一个变量，即指针变量；&p_double，取指针变量 p_double 的地址

	system("pause");
	return 0;
}
```

```
        &i = 0037F9E4
     p_int = 0037F9E4
    &p_int = 0037F9D8
        &c = 0037F9CF
    p_char = 0037F9CF
   &p_char = 0037F9C0
        &d = 0037F9B0
 &p_double = 0037F9B0
 &p_double = 0037F9A4
```

下列情形并不一定需要使用 & 取地址：
- 数组名，是数组里第一个元素的地址。
- 函数名，是函数的地址。
- 字符串，是字符串里第一个字符的地址。 

## 解引用
对一个指针解引用，就可以取到这个地址所存储的数据。解引用的写法，就是在指针的前面加一个 * 号。

解引用的实质是：从指针所指向的内存地址中取出这个内存数据。

```c
#include <stdio.h>

int main() {
	int num = 10;
	int* p = &num;
	printf_s("num = %d, *p = %d\n", num, *p); // *p，读取指针变量所指向的地址里的数据
	*p = 15; // 修改指针变量所指向的地址里的数据，即修改变量i的数据
	printf_s("num = %d, *p = %d\n", num, *p);

	system("pause");
	return 0;
}
```

```
num = 10, *p = 10
num = 15, *p = 15
```

## 指针之间的赋值
指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝。

```c
#include <stdio.h>

int main() {
	int num = 10;
	int* p1 = &num;
	int* p2 = p1; // 把指针变量 p1 赋值给指针变量 p2，即指针变量 p1、p2 都指向 num 的地址，或者说指针变量 p1、p2 存储的都是变量 num 的地址
	printf_s("p1 = %p, *p1 = %d\n", p1, *p1);
	printf_s("p2 = %p, *p2 = %d\n", p2, *p2);

	// 通过指针变量 p1 、 p2 都可以对 num 进行读写
	*p1 = 15;
	printf_s("num = %d, *p1 = %d, *p2 = %d\n", num, *p1, *p2);
	*p2 = 20;
	printf_s("num = %d, *p1 = %d, *p2 = %d\n", num, *p1, *p2);

	system("pause");
	return 0;
}
```

```
p1 = 0030FE18, *p1 = 10
p2 = 0030FE18, *p2 = 10
num = 15, *p1 = 15, *p2 = 15
num = 20, *p1 = 20, *p2 = 20
```

## 空指针
指向空，或者说不指向任何地址。在 C 语言中，指针变量赋值为 NULL，表示一个空指针，NULL实质是 ((void*)0)。

任何数据都不会存储在地址为 0 的内存中，它是被操作系统预留的内存地址。

## 坏指针
指针变量的值是 NULL ，或者是未知的地址，或者是当前应用程序不可访问的地址，这样的指针就是坏指针，不能对它们做解引用操作，否则程序会出现运行时错误，导致程序意外终止。

任何一个指针变量在做解引用操作前，都必须保证它指向的是有效的、可用的内存地址，否则就会出错。

```c
void error_example1() {
	int* p = NULL;
	*p = 10; // 不能对 NULL 做解引用操作
}

void error_example2() {
	int* p;
	*p = 10; // 不能对未知的地址做解引用操作
}

void error_example3() {
	int* p = (int*)1000; // 指针变量 p 指向内存地址 0x3E8，该地址并不属于本进程的内存地址
	*p = 10; // 不能对一个不属于本进程的内存地址做解引用操作
}
```

## void* 类型指针
** 编译器不允许直接对 void* 类型的指针做解引用操作。**

由于 void 是空类型，因此 void* 类型的指针只保存了指针的值，而丢失了类型信息，我们不知道它指向的数据是什么类型的，只知道这个数据在内存中的起始地址，如果想要完整的提取指向的数据，我们就必须对这个指针做出正确的类型转换，然后再解引用。用。
