# 指针与数组
## 指针与数组的关系
```c
int arr[5];
int* p;
```

1. 数组名 arr 本身就是一个指针，它指向数组的第一个元素

2. 因为 arr 本身是指针，所以可以直接赋值给同类型的指针， p = arr 等价于 p = &arr[0]
```c
#include <stdio.h>

int main() {
	int arr[5] = { 1,2,3 };
	int* p;
	//p = &arr[0];
	p = arr;
	printf_s("%8s = %8d, %8s = %8d, %8s = %8d\n", "*p", *p, "arr[0]", arr[0], "*arr", *arr);
	printf_s("%8s = %p, %8s = %p, %8s = %p\n", "p", p, "arr", arr, "&arr[0]", &arr[0]);

	system("pause");
	return 0;
}
```

```
      *p =        1,   arr[0] =        1,     *arr =        1
       p = 0026F844,      arr = 0026F844,  &arr[0] = 0026F844
```

3. 指针和数组名在效果上是等价的。但是，指针变量可以参与表达式的计算，如 p++ 和 p = arr 是有效的，而数组名不可以参与表达式的计算，如 arr = p 和 a++ 是无效的。
```c
#include <stdio.h>

int main() {
	int arr[5] = { 1,2,3 };
	int* p = arr;
	printf_s("*p = %d\n", *p);
	p++;
	printf_s("*p = %d\n", *p);

	system("pause");
	return 0;
}
```

```
*p = 1
*p = 2
```

4. 数组的各元素在内存中是连续的，可以通过索引下标的方式 arr[i] 获取任意一个元素，而 arr[i+1] 一定代表下一个元素（除非数组索引越界），arr[i-1] 一定代表前一个元素（除非数组索引越界）
```c
#include <stdio.h>

int main() {
	int arr[5] = { 1,2,3 };
	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
		printf_s("%d\t", arr[i]);
	}
	printf_s("\n");

	system("pause");
	return 0;
}
```

```
1       2       3       0       0
```

5. 因为数组名也是指针，所以也可以将获取元素的方式写成 *(arr)，它等价于 arr[0] ，即代表第一个元素的值。同理，*(arr+1) 等价于 arr[1] 即表示第二个元素，*(arr+i) 等价于 arr[i] 即表示第 i+1 个元素
```c
printf_s("%d\t", *(arr + i));
```

6. 也可以直接通过指针的加减法运算取得对应位置的元素地址。p 代表的是第一个元素的地址，p + 1 代表第二个元素地址，p + i 代表第 i + 1 个元素的地址
```c
#include <stdio.h>

int main() {
	int arr[5] = { 1,2,3 };
	int *p = arr;
	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
		printf_s("%d\t", *(p + i));
	}
	printf_s("\n");

	system("pause");
	return 0;
}
```

```
1       2       3       0       0
```

7. 实际上，数组索引下标运算就是先取指针，再通过指针去取得对应元素。所以，使用指针的效率比使用索引下标取数组值的效率要高

8. 指针和数组之间的等价方式

|等价方式|描述|
|--|--|
|&arr[i]; arr + i; p + i;|都表示 inde x= i 元素的地址|
|arr[i]; *(arr + i); *(p + i);|都表示 index = i 元素的值|

## 指针运算
```c
#include <stdio.h>

int main() {
	int arr[10] = { 95,100,3,10,25,20,60,90,55,1 };
	int *p = arr;

	printf_s("%d\n", *p); // 取数组的第 1 个元素

	// p += 1
	p++; // 指针后移 1 位，即指向第 2 个元素的地址
	printf_s("%d\n", *p); // 取数组的第 2 个元素

	// 一元运算符 * 和 ++ 的优先级相同，它们从右向左运算
	printf_s("%d\n", *++p); // 指针先后移 1 位，再取数组的第 3 个元素

	printf_s("%d\n", *p); // 取数组的第 3 个元素

	printf_s("%d\n", *p++); // 取数组的第 3 个元素，但是指针已经指向第 4 个元素的地址了

	printf_s("%d\n", *p); // 取数组的第 4 个元素

	int* p1 = &arr[1];
	int* p2 = &arr[6];

	printf_s("p2 - p1 = %d\n", p2 - p1); // 计算两个指针之间的元素个数

	system("pause");
	return 0;
}
```

```
95
100
3
3
3
10
p2 - p1 = 5
```

## 指针数组
**指针数组是一个数组，数组中的每一个元素都是指针。**

声明一个指针数组的方法如下：

```c
int* p[10];    // 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针
```

在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int* 指明这是一个 int 类型的指针数组，数组中的每个元素都是指向 int 类型的指针。

```c
#include <stdio.h>

int main() {
	int arr[10] = { 95,100,3,10,25,20,60,90,55,1 };
	int len = sizeof(arr) / sizeof(arr[0]);

	for (int i = 0; i < len; i++) {
		printf_s("&arr[%d] = %p\n", i, &arr[i]);
	}

	int* p[10];
	// 把 int 类型数组 arr 的每个元素的地址依次赋值给指针数组 p 的每个元素
	for (int i = len - 1; i >= 0; i--) {
		p[len - 1 - i] = arr + i;
	}
	for (int i = 0; i < len; i++) {
		printf_s("p[%d] = %p, *p[%d] = %d\n", i, p[i], i, *p[i]);
	}

	system("pause");
	return 0;
}
```

```
&arr[0] = 0043FCF0
&arr[1] = 0043FCF4
&arr[2] = 0043FCF8
&arr[3] = 0043FCFC
&arr[4] = 0043FD00
&arr[5] = 0043FD04
&arr[6] = 0043FD08
&arr[7] = 0043FD0C
&arr[8] = 0043FD10
&arr[9] = 0043FD14
p[0] = 0043FD14, *p[0] = 1
p[1] = 0043FD10, *p[1] = 55
p[2] = 0043FD0C, *p[2] = 90
p[3] = 0043FD08, *p[3] = 60
p[4] = 0043FD04, *p[4] = 20
p[5] = 0043FD00, *p[5] = 25
p[6] = 0043FCFC, *p[6] = 10
p[7] = 0043FCF8, *p[7] = 3
p[8] = 0043FCF4, *p[8] = 100
p[9] = 0043FCF0, *p[9] = 95
```

## 数组指针
**数组指针是一个指针，它指向一个数组。**

声明一个数组指针的方法如下：

```c
int (*p)[10];        // 声明一个数组指针 p ，该指针指向一个数组
```
由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，**执行 p + 1 时，p 要跨过 n 个 int 型数据的长度。** 数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：

```c
#include <stdio.h>

int main() {
	int arr[2][3] = { 1,2,3,4,5,6 };
	int(*p)[3]; // 定义一个数组指针，指针指向一个含有 3 个元素的一维数组

	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 3; j++) {
			printf_s("&arr[%d][%d] = %p\t", i, j, arr[i]+j); // arr[i]+j 等价于 &arr[i][j]
		}
		printf_s("\n");
	}

	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 3; j++) {
			printf_s("arr[%d][%d] = %d\t", i, j, arr[i][j]);
		}
		printf_s("\n");
	}

	p = arr; // 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &arr[0][0]
	for (int i = 0; i < 3; i++) {
		printf_s("p[%d] = %p\t", i, p[0] + i); // p[0] + i 等价于 &(*p)[i]
	}
	printf_s("\n");
	for (int i = 0; i < 3; i++) {
		printf_s("(*p)[%d] = %d\t", i, (*p)[i]);
	}
	printf_s("\n");

	p++; // 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &arr[1][0]
	printf_s("(*p)[1] = %d\n", (*p)[1]);

	system("pause");
	return 0;
}
```

```
&arr[0][0] = 003CFC00   &arr[0][1] = 003CFC04   &arr[0][2] = 003CFC08
&arr[1][0] = 003CFC0C   &arr[1][1] = 003CFC10   &arr[1][2] = 003CFC14
arr[0][0] = 1   arr[0][1] = 2   arr[0][2] = 3
arr[1][0] = 4   arr[1][1] = 5   arr[1][2] = 6
p[0] = 003CFC00 p[1] = 003CFC04 p[2] = 003CFC08
(*p)[0] = 1     (*p)[1] = 2     (*p)[2] = 3
(*p)[1] = 5
```

## 二维数组中地址的表示形式
|表示形式|含义|
|--|--|
|arr; arr[0]; *(arr + 0); *arr; &arr[0][0];|arr[0][0]的地址|
|arr + 1; arr[1]; &arr[1]; *(arr + 1); &arr[0][1];|arr[0][1]的地址|
|arr[1] + 2; *(arr + 1) + 2; &arr[1][2];|arr[1][2]的地址|
|*(arr[1] + 2); \*(\*(arr + 1) + 2); arr[1][2];|arr[1][2]的值|
