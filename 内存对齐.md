# 内存对齐
## 概念 
对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在 32 位 cpu 下，假设一个整型变量的地址为 0x00000004，那它就是自然对齐的。

## 为什么要内存对齐
需要内存对齐的根本原因在于 CPU 访问数据的效率问题。

假设上面整型变量的地址不是自然对齐，比如为 0x00000002，则 CPU 如果取它的值的话需要访问两次内存，第一次取从 0x00000002-0x00000003 的一个 short，第二次取从 0x00000004-0x00000005 的一个 short，然后组合得到所要的数据；

如果变量在 0x00000003 地址上的话则要访问三次内存，第一次为 char，第二次为 short，第三次为 char，然后组合得到整型数据。

而如果变量在自然对齐位置上，则只要一次就可以取出数据。

比如下面两个结构体:
```c
typedef struct _a
{
	int x1;
	double x2;
	short x3;
}A;

typedef struct _b
{
	int x1;
	short x3;
	double x2;
}B;
```
结构体 A 和 B 的成员完全一样，都包含一个 int 类型的 x1、一个 double 类型的 x2 和一个 short 类型的 x3；在 32 位机器上 int 占 4 个字节，double 占 8 个字节，short 占 2 个字节，那么这两个结构体的大小都是 14 个字节吗？

先看看程序的输出：

```c
#include <stdio.h>

typedef struct _a
{
	int x1;
	double x2;
	short x3;
}A;

typedef struct _b
{
	int x1;
	short x3;
	double x2;
}B;

int main() {
	printf_s("size A = %d\n", sizeof(A));
	printf_s("size B = %d\n", sizeof(B));
	system("pause");
	return 0;
}
```

```
size A = 24
size B = 16
```

结构体 A 的大小是 24，结构体 B 的大小是 16；这两个结构体的大小不仅不相等，并且都比前面计算的结果要大。这是因为编译器在编译的时候进行了内存对齐的原因。

## 内存对齐的原则
### 标准数据类型
对于标准数据类型，它的地址只要是它的长度的整数倍就行了。

### 非标准数据类型
对于非标准数据类型，按下面的原则对齐：
- 数组：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。 
- 联合：按其包含的最大长度的数据类型对齐。 
- 结构体： 结构体中每个数据类型都要对齐。
   - 按照结构体成员的声明顺序，依次进行内存对齐。
   - 结构体成员的起始地址能够被其最宽的成员大小整除，0 看做任何成员的整数倍。
   - 结构体每个成员的起始地址能够被其数据类型的长度整除，如果不能就在前一个成员后面补充字节。比如 4 个字节的 int 型数据，其起始地址应该位于 4 字节的边界上，即起始地址能够被 4 整除。
   - 结构体的大小能够被最宽的成员大小（最宽的成员，即数据类型占用字节最长的成员）整除，如果不能就在后面补充字节。比如结构体大小是 10，而结构体里最宽的成员是 8 个字节的 double 型，
   由于 10 / 8 的余数不等于 0，就需要在最后补充 6 个字节，也就是结构体的大小是 16。

### 结构体内存对齐的计算步骤
假设在 32 位机器上，结构体的起始地址为 0x00000000，这里分析一下上述示例里的结构体 A 和 B 的大小。

#### 计算结构体 A 的大小
```c
typedef struct _a
{
	int x1;
	double x2;
	short x3;
}A;
```

1. x1 占 4 个字节，地址从 0x00000000，由于 0x00000000 是自然对齐的，因此 x1 对齐后的地址是 0x00000000 - 0x00000003；
2. x2 占 8 个字节，地址从 0x00000004 开始，由于 0x00000004 不能被 8 整除，所以 x2 的地址需要从 0x00000008 开始；那么 x1 就需要补充 4 个字节，即 x1 占用 8 个字节；因此 x1 对齐后的地址是 0x00000000 - 0x00000007，x2 对齐后的地址是 0x00000008 - 0x0000000F;
3. x3 占 2 个字节，地址从 0x00000010 开始，由于 0x00000010 能够被 2 整除，所以 x3 对齐后的地址是 0x00000010 - 0x00000011;
4. x1 占 8 个字节，x2 占 8 个字节，x3 占 2 个字节，此时计算得到的结构体大小为 8 + 8 + 2 = 18，最宽的成员占 8 个字节，由于 18 / 8 的余数不等于 0， 为了满足结构体的大小是 8 的倍数，x3 需要补充 6 个字节，即 x3 占用 8 个字节；因此 x3 对齐后的地址是 0x00000010 - 0x00000017; 
5. 综上所述，x1 占 8 个字节，x2 占 8 个字节，x3 占 8 个字节，结构体的大小为 8 + 8 + 8 = 24。

#### 计算结构体 B 的大小
```c
typedef struct _b
{
	int x1;
	short x3;
	double x2;
}B;
```

1. x1 占 4 个字节，地址从 0x00000000，由于 0x00000000 是自然对齐的，因此 x1 对齐后的地址是 0x00000000 - 0x00000003；
2. x3 占 2 个字节，地址从 0x00000004 开始，由于 0x00000004 能够被 2 整除，所以 x3 对齐后的地址是 0x00000004 - 0x00000005;
3. x2 占 8 个字节，地址从 0x00000006 开始，由于 0x00000006 不能被 8 整除，所以 x2 的地址需要从 0x00000008 开始；那么 x3 就需要补充 2 个字节，即 x3 占用 4 个字节；因此 x3 对齐后的地址是 0x00000004 - 0x00000007，x2 对齐后的地址是 0x00000008 - 0x0000000F;
4. x1 占 4 个字节，x2 占 4 个字节，x3 占 8 个字节，此时计算得到的结构体大小为 4 + 4 + 8 = 16，最宽的成员占 8 个字节，由于 16 / 8 的余数等于 0，所以结构体的大小为 16。
