# 内存对齐
## 概念 
对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在 32 位 cpu 下，假设一个整型变量的地址为 0x00000004，那它就是自然对齐的。

## 为什么要字节对齐
需要字节对齐的根本原因在于 CPU 访问数据的效率问题。

假设上面整型变量的地址不是自然对齐，比如为 0x00000002，则 CPU 如果取它的值的话需要访问两次内存，第一次取从 0x00000002-0x00000003 的一个 short，第二次取从 0x00000004-0x00000005 的一个 short，然后组合得到所要的数据；

如果变量在 0x00000003 地址上的话则要访问三次内存，第一次为 char，第二次为 short，第三次为 char，然后组合得到整型数据。

而如果变量在自然对齐位置上，则只要一次就可以取出数据。

## 内存对齐的原则
### 标准数据类型
对于标准数据类型，它的地址只要是它的长度的整数倍就行了。

### 非标准数据类型
对于非标准数据类型，按下面的原则对齐：
- 数组：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。 
- 联合：按其包含的最大长度的数据类型对齐。 
- 结构体： 结构体中每个数据类型都要对齐。
   - 结构体变量的起始地址能够被其最宽的成员大小整除，0 看做任何成员的整数倍。
   - 结构体每个成员的起始地址能够被其数据类型的长度整除，如果不能就在前一个成员后面补充字节。比如 4 个字节的 int 型数据，其起始地址应该位于 4 字节的边界上，即起始地址能够被 4 整除。
   - 结构体的大小能够被最宽的成员大小（最宽的成员，即数据类型占用字节最长的成员）整除，如果不能就在后面补充字节。比如结构体大小是 10，而结构体里最宽的成员是 8 个字节的 double 型，
   那么 10 / 8 的余数不等于 0，就需要在最后补充 6 个字节，也就是结构体的大小是 16。

### 结构体内存对齐的计算步骤
假如结构体的起始地址为 0x00000000

```c
typedef struct _size
{
	char x1;
	int x2;
  float x3;
	double x4;
}Size;
```

1. x1 占 1 个字节，即 0x00000000；
2. x2 占 4 个字节，地址从 0x00000001 开始，由于 0x00000001 不能被 4 整除，所以 x1 需要补充 3 个字节，即 x1 占用 4 个字节，所占用的地址是 0x00000000 - 0x00000003；此时 x2 所占用的地址是 0x00000004 - 0x00000007;
3. x3 占 4 个字节，地址从 0x00000008 开始，由于 0x00000008 能够被 4 整除，所以x3 所占用的地址是 0x00000008 - 0x0000000B;
4. x4 占 8 个字节，地址从 0x0000000C 开始，由于 0x0000000C 不能被 8 整除，所以 x3 需要补充 4 个字节，即 x3 占用 8 个字节，所占用的地址是 0x00000008 - 0x0000000F；此时 x4 所占用的地址是 0x00000010 - 0x00000013;
5. 
